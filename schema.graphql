# Uniswap global values 
type Uniswap @entity {
  id: ID!
  
  # exchange info 
  exchangeCount: Int!
  exchanges: [Exchange]!

  # total volume 
  totalVolumeUSD: BigDecimal!             
  totalVolumeEth: BigDecimal!

  # total volume traded ever in USD
  totalLiquidityUSD: BigDecimal!  
  totalLiquidityEth: BigDecimal!
           
  # counters for ids               
  exchangeHistoryEntityCount: BigInt!     
  uniswapHistoryEntityCount: BigInt!    
  tokenHistoryEntityCount: BigInt!      
  txCount: BigInt!                        
}

# stores for USD calculations 
type Bundle @entity {
  id: ID!
  ethPrice: BigDecimal! # price of ETH usd
  # daiPrice: BigDecimal! # price of ETH in DAI

  # add these later
  # USDC: BigDecimal! # price of ETH is usdc 
  # TUSD: BigDecimal! # price of ETH in TUSD
}

# Stats about a Uniswap exchange 
type Exchange @entity {
  id: ID! #exchange address

  # token info 
  token0: Token!
  token1: Token!

  # useful stats 
  startTime: Int!
  totalTxsCount: BigInt!                  

  # liquidity info 
  token0Balance: BigDecimal!
  token1Balance: BigDecimal!
  combinedBalanceEth: BigDecimal!  
  combinedBalanceUSD: BigDecimal!  
  totalUniToken: BigDecimal!

  # volume info      
  tradeVolumeToken0: BigDecimal!
  tradeVolumeToken1: BigDecimal!
  tradeVolumeEth: BigDecimal!             
  tradeVolumeUSD: BigDecimal!

  # price info - token0 per token1, etc
  token0Price: BigDecimal! 
  token1Price: BigDecimal!

  # derivations 
  factory: Uniswap! @derivedFrom(field: "exchanges")
}

# stats about an individual token (can exist on multiple exchanges)
type Token @entity {
  # id is the token address
  id: ID! 
  symbol: String                     
  name: String                       
  decimals: Int   

  # derived prices
  derivedETH: BigDecimal # eth per token 
  
  # token specific volume
  tradeVolumeToken: BigDecimal!
  tradeVolumeETH: BigDecimal!
  tradeVolumeUSD: BigDecimal!   

  # liquidity across all pairs 
  totalLiquidityToken: BigDecimal!            
  totalLiquidityUSD: BigDecimal!      

  # address of weth exchange if exists 
  wethExchange: Bytes

  # all pairs a token is a part of 
  allPairs: [Exchange!]
}


type User @entity {
    # user eth address
    id: ID!    
    # all exhanges user has shares within 
    exchangeBalances: [UserExchangeData!]!  @derivedFrom(field: "user")
}

type UserExchangeData @entity {
    # ID is concatenation of exchange addr and user addr. i.e. 0xahiow4-0xkashkd34....
    id: ID!   
    userAddress: Bytes!
    user: User!
    exchange: Exchange!

    # token0 info 
    token0Deposited: BigDecimal!     
    token0Withdrawn: BigDecimal!

    # token1 info
    token1Deposited: BigDecimal!    # Where negative means tokens were exchanged for eth
    token1Withdrawn: BigDecimal!
    
    # balance of lp shares for this exchange
    uniTokenBalance: BigDecimal!  

    # swapping data 
    token0Bought: BigDecimal!
    token0Sold: BigDecimal!
    token1Bought: BigDecimal!
    token1Sold: BigDecimal!
}

type Transaction @entity {
    id: ID!  # txn  hash concatenated with exchange - need this for token to token swaps
    exchange: Exchange!
    token0: String!
    token1: String!
    valueUSD: BigDecimal!
    valueETH: BigDecimal!
    addLiquidityEvents: [AddLiquidityEvent!]
    removeLiquidityEvents: [RemoveLiquidityEvent!]
    swapEvents: [SwapEvent!]
    block: Int!
    timestamp: Int!
    user: Bytes!
}

interface TransactionEvent {
  id: ID!
  transaction: Transaction!
  token0Amount: BigDecimal!
  token1Amount: BigDecimal!

}

type AddLiquidityEvent implements TransactionEvent  @entity {
    id: ID!             
    transaction: Transaction! @derivedFrom(field: "addLiquidityEvents")
    token0Amount: BigDecimal!
    token1Amount: BigDecimal!
}

type RemoveLiquidityEvent implements TransactionEvent @entity {
    id: ID!              
    transaction: Transaction! @derivedFrom(field: "removeLiquidityEvents")
    token0Amount: BigDecimal!
    token1Amount: BigDecimal!
}

type SwapEvent @entity {
    id: ID!              
    transaction: Transaction! @derivedFrom(field: "swapEvents")
    tokenSoldAmount: BigDecimal!
    tokenBoughtAmount: BigDecimal!
}

# Data checkpointed at each event
type UniswapHistoricalData @entity {
    id: ID!  # unique based on incremental entity count, one for each transactions
    timestamp: Int!
    totalVolumeUSD: BigDecimal!   # accumulated at each trade         
    totalLiquidityUSD: BigDecimal!
    txCount: BigInt!
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
    id: ID! # timestamp rounded to current day by dividing by 86400 - should only be one per day
    date: Int!
    dailyVolumeUSD: BigDecimal!
    totalVolumeUSD: BigDecimal!          
    totalLiquidityUSD: BigDecimal!
    txCount: BigInt!
}



enum EventType {
    AddLiquidity,
    RemoveLiquidity,
    TokenPurchase,
    EthPurchase
}

type ExchangeHistoricalData @entity {
    id: ID!
    exchangeAddress: Bytes!
    type: EventType!
    timestamp: Int!

    # liquidity
    token0Balance: BigDecimal!              
    token1Balance: BigDecimal!             
    combinedBalanceUSD: BigDecimal!      
    totalUniToken: BigDecimal!   
    
    # volume
    tradeVolumeToken0: BigDecimal!           
    tradeVolumeToken1: BigDecimal!           
    tradeVolumeEth: BigDecimal!  
    tradeVolumeUSD: BigDecimal!             

    # pricing
    token0Price: BigDecimal!            
    token1Price: BigDecimal!            

    # txns
    totalTxsCount: BigInt!  
}

# Data accumulated and condensed into day stats for each exchange
type ExchangeDayData @entity {
    id: ID!                              
    date: Int!                           
    exchangeAddress: Bytes!
    token0Balance: BigDecimal!              
    token1Balance: BigDecimal!      
    combinedBalanceUSD: BigDecimal!                          
    dailyVolumeToken0: BigDecimal!               
    dailyVolumeToken1: BigDecimal! 
    dailyVolumeUSD: BigDecimal!          
    dailyTxns: BigInt!          
}

type TokenHistoricalData @entity {
    id: ID!
    token: Token!
    timestamp: Int!
    
    # volume
    tradeVolumeToken: BigDecimal!           
    tradeVolumeETH: BigDecimal!           
    tradeVolumeUSD: BigDecimal! 

    totalLiquidityToken: BigDecimal!            
    totalLiquidityUSD: BigDecimal!            

    # pricing
    priceEth: BigDecimal!            
    priceUSD: BigDecimal!            
}

# Data accumulated and condensed into day stats for each token across all pairs 
type TokenDayData @entity {
    id: ID!                              
    date: Int!                           
    token: Token!     
    dailyVolumeToken: BigDecimal!   
    dailyVolumeETH: BigDecimal!               
    dailyVolumeUSD: BigDecimal! 
    dailyTxns: BigInt! 
    totalLiquidityToken: BigDecimal!
    totalLiquidityUSD: BigDecimal!
}



